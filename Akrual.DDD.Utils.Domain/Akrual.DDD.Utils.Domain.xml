<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akrual.DDD.Utils.Domain</name>
    </assembly>
    <members>
        <member name="T:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1">
            <summary>
                Base class for implementing aggregate root domain objects.
                <remarks><c>No external code should access the internal objects of this Aggregate!</c></remarks>
                <remarks><c>So add properties as private or maximum internal only!</c></remarks>
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.EventsLoaded">
            <summary>
            The number of events loaded into this aggregate.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="!:AggregateRoot"/> class.
            Every constructor have to satisfy:
                <remarks><c>GUID. This must be unique in the whole Application.!</c></remarks>
                <remarks><c>You should probably extend this constructor to include every property that makes this entity unique.</c></remarks>
            </summary>
            <param name="id">Aggregate root instance id.</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.GetEventStream">
            <summary>
            Gets all domain events that have been applied to the aggregate root instance.
            </summary>
            <returns>A collection of domain events.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.ApplyEvents(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent})">
            <summary>
            Enuerates the supplied events and applies them in order to the aggregate.
            </summary>
            <param name="domainEvents"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.ApplyEvents(Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent[])">
            <summary>
            Enuerates the supplied events and applies them in order to the aggregate.
            </summary>
            <param name="domainEvents"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.ApplyOneEvent``1(``0)">
            <summary>
            Applies a single event to the aggregate.
            <remarks>Normally thuis method should not be used. Because, the Aggregate
            when implementing one IApplyDomainEvent, will be automatically callede when an event is published.</remarks>
            </summary>
            <typeparam name="TEvent"></typeparam>
            <param name="ev"></param>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Entities.BaseDomainStatus">
            <summary>
            An Abstract Class to inherit when creating Entity Status
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Entities.Entity`1">
            <summary>
                Base class for any Entity Type (i.e. the 'Entity Object' of DDD).
                <remarks><c>All properties of this child classes should have the setter as private!</c></remarks>
            </summary>
            <typeparam name="T">Domain type to be 'turned' into a Entity Type.</typeparam>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Entities.Entity`1.IsValid">
            <exception cref="T:Akrual.DDD.Utils.Internal.Exceptions.ShouldNeverCallIsValidOnTheEntityException">Should never call It!!</exception>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Entities.Entity`1.#ctor(System.Guid,Akrual.DDD.Utils.Domain.Entities.IEntity)">
            <summary>
                Initializes a new instance of the <see cref="!:Entity"/> class.
                Every constructor have to satisfy:
                <remarks><c>If the entity is not an Aggregate Root, then it cannot be created without passing the owner of this entity (Some entity inside the Aggregate, maybe the Aggregate root)!</c></remarks>
                <remarks><c>GUID. This must be unique inside the Aggegate.!</c></remarks>
                <remarks><c>You should probably extend this constructor to include every property that makes this entity unique.</c></remarks>
            </summary>
            <param name="id"></param>
            <param name="owner"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Entities.Entity`1.#ctor">
            <summary>
            It should never be possible to Create an Entity without and ID and an Owner.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Exceptions.DomainException">
            <summary>
            Base Exception for exceptions related with Domain
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.Factory`2.CreateDefaultInstance">
            <summary>
                Creates the default Aggregate. It should be already filled with the UUID.
                <remarks><c>Use GuidGenerator to generate UUID!</c></remarks>
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.Factory`2.Create">
            <summary>
            Creates the Aggregate with all the invariants Checked
            </summary>
            <returns>Returns the Filled Aggregate with all the invariants Checked.</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand">
            <summary>
            Base class for implementing domain Commands that represent the will for something to happen.
            It by default expect the handler to return an IEnumerable&lt;DomainEvent&gt;
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand.AggregateRootId">
            <summary>
            Gets the Aggregate Root id.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand.#ctor(System.Guid,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand"/> class.
            </summary>
            <param name="aggregateRootId">Aggregate Root id.</param>
            <param name="entityVersion">Entity instance version.</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand"/> class.
            </summary>
            <param name="aggregateRootId">Aggregate Root instance id.</param>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext">
            <summary>Represents a command context for aggregate command handler handling command.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext.Add``2(``0)">
            <summary>Add a new aggregate into the current command context.
            </summary>
            <param name="aggregateRoot"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext.Get``2(System.Object,System.Boolean)">
            <summary>Get an aggregate from the current command context.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TInside"></typeparam>
            <param name="id"></param>
            <param name="firstFromCache"></param>
            <returns></returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext.SetResult(System.String)">
            <summary>Set the command handle result.
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext.GetResult">
            <summary>Get the command handle result.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandDispatcher`1">
            <summary>
            Represents the interface of a command dispatcher. All Commands will be dispatched through a dispatcher
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.IDomainCommand`1">
            <summary>
            Domain Command that represents the will for something to happen
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.IDomainCommand`1.AggregateRootId">
            <summary>
            Gets the entity id.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.IHandleDomainCommand`1">
            <summary>Represents generic command handler.
            </summary>
            <typeparam name="TCommand"></typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent">
            <summary>
            Base class for implementing domain events that represent changes in a domain entity.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent.AggregateRootId">
            <summary>
            Gets the entity id.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent.#ctor(System.Guid,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent"/> class.
            </summary>
            <param name="aggregateRootId">Entity instance id.</param>
            <param name="entityVersion">Entity instance version.</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent"/> class.
            </summary>
            <param name="aggregateRootId">Entity instance id.</param>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent">
            <summary>
            Domain event that represents changes in a domain entity.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent.AggregateRootId">
            <summary>
            Gets the entity id.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IEventPublisher`1">
            <summary>
            Interface 
            </summary>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IHandleDomainEvent`1">
            <summary>
            Implemented by an aggregate once for each event type it can apply.
            </summary>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.IMessaging">
            <summary>
            Messages (and not objects, objects are data + behavior).
            In some respects much like DTOs, they communicate data 
            about an event and they themselves encapsulate no behavior
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.Saga.IProcessManagerRedirect`1">
            <summary>
            Interface that must be added to a Process Manager Class for each redirection that it will implement.
            </summary>
            <typeparam name="TInEvent">The event that the process manager will receive</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.Saga.IProcessManagerRedirect`1.Redirect(`0)">
            <summary>
            For a given Event, it return a list of messages (Events and Commands) that shall be published/dispatched
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Repositories.IAsyncDomainRepository`2">
            <summary>
            Asynchronous domain repository for a given aggregate root type.
            </summary>
            <typeparam name="TAggregate">The type of the aggregate root.</typeparam>
            <typeparam name="T">The type of the aggregate root Inner object.</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Repositories.IAsyncDomainRepository`2.FindByIdAsync(System.Guid)">
            <summary>
            Asynchronously finds an aggregate root instance from the repository using its id.
            </summary>
            <param name="id">Aggregate root instance id.</param>
            <returns>Aggregate root instance.</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.BaseDomainRule`2">
            <summary>
            Base class for Rule Definition. It should receive one Entity as input (TEntity) and return a value as Output (TRuleReturn). This output will be used in the RuleExecutor.
            </summary>
            <typeparam name="TEntity">The type of the Input</typeparam>
            <typeparam name="TRuleReturn">The type of the Output</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRule`2.EvaluateRules(`0)">
            <summary>
            Evaluate all Rules to a specific entity and and return output
            </summary>
            <param name="entity">Any entity object that will be analysed</param>
            <returns>Evaluated value</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2">
            <summary>
            Represents a rule Engine Executor. It will Crunch all the Rules associated to it and return the final output.
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TRuleReturn"></typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.#ctor(Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}[])">
            <summary>
            Instantiates the Rule Evaluator passing the rules as parameters
            </summary>
            <param name="rules">The rules to instantiate the evaluator</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.#ctor(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}})">
            <summary>
            Instantiates the Rule Evaluator passing the rules as an IEnumerable as parameter
            </summary>
            <param name="rules">The rules to instantiate the evaluator</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.AddRule(Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}[])">
            <summary>
            Adds Rule to Rules Evaluation. And return True if succeeds
            </summary>
            <param name="rules">The rules beeing added to evaluation</param>
            <returns>True if added sucessfully</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.AddRule(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}})">
            <summary>
            Adds Rule to Rules Evaluation. And return True if succeeds
            </summary>
            <param name="rules">The rules beeing added to evaluation</param>
            <returns>True if added sucessfully</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.RemoveRule(Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}[])">
            <summary>
                Removes Rule to Rules Evaluation. And return True if succeeds
                <remarks><c>It will only work if the instance being passed to be removed is the same as the one initially added!</c></remarks>
            </summary>
            <param name="rules">The rules beeing removed to evaluation</param>
            <returns>True if removed sucessfully</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.RemoveRule(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}})">
            <summary>
                Removes Rule to Rules Evaluation. And return True if succeeds
                <remarks><c>It will only work if the instance being passed to be removed is the same as the one initially added!</c></remarks>
            </summary>
            <param name="rules">The rules beeing removed to evaluation</param>
            <returns>True if removed sucessfully</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.ExecuteAllRules(`0)">
            <summary>
                Evaluates all Rules registered to the given entity and return the result.
                <remarks><c>Here is added the logic of the order, min, max, etc.</c></remarks>
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.AndDomainRule`1">
            <summary>
            This Rule is used to wrap two Boolean rules using an AND expression.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.AndDomainRule`1.#ctor(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0},Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            Creates a Rule that is used to wrap two Boolean rules using an AND expression.
            </summary>
            <param name="left">Left side of the Boolean Expression</param>
            <param name="right">Right side of the Boolean Expression</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.AndDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BooleanDomainRuleBuilder`1">
            <summary>
            A builder to create Complex DomainRules based on Boolean Expressions. It can Wrap rules in AND, OR, XOR statements.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BooleanDomainRuleBuilder`1.#ctor(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            creates a builder to create Complex DomainRules based on Boolean Expressions. It can Wrap rules in AND, OR, XOR statements.
            It receives an initial rule. If none is provided, it will start with a Always true rule.
            </summary>
            <param name="initial"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BooleanDomainRuleBuilder`1.Create">
            <summary>
            Start the Fluent Creation Proccess
            </summary>
            <returns>Fluent object to create</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BooleanDomainRuleBuilder`1.And(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            
            </summary>
            <param name="initial"></param>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule`1">
            <summary>
            This is a Base Class to define any rules that return a Boolean.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.FalseDomainRule`1">
            <summary>
            This is a Dummy Rule used to start some Complex boolean rule.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.FalseDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.OrDomainRule`1">
            <summary>
            This Rule is used to wrap two Boolean rules using an OR expression.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.OrDomainRule`1.#ctor(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0},Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            Creates a Rule that is used to wrap two Boolean rules using an OR expression.
            </summary>
            <param name="left">Left side of the Boolean Expression</param>
            <param name="right">Right side of the Boolean Expression</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.OrDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.TrueDomainRule`1">
            <summary>
            This is a Dummy Rule used to start some Complex boolean rule.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.TrueDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.XorDomainRule`1">
            <summary>
            This Rule is used to wrap two Boolean rules using an XOR expression.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.XorDomainRule`1.#ctor(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0},Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            Creates a Rule that is used to wrap two Boolean rules using an XOR expression.
            </summary>
            <param name="left">Left side of the Boolean Expression</param>
            <param name="right">Right side of the Boolean Expression</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.XorDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonRuleExecutors.BooleanDomainRuleEvaluator`1">
            <inheritdoc />
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonRuleExecutors.BooleanDomainRuleEvaluator`1.#ctor(Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,System.Boolean}[])">
            <inheritdoc />
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonRuleExecutors.BooleanDomainRuleEvaluator`1.#ctor(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,System.Boolean}})">
            <inheritdoc />
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonRuleExecutors.BooleanDomainRuleEvaluator`1.ExecuteAllRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.IDomainRule`2">
            <summary>
            Base interface for Rule Definition. It should receive one Entity as input (TEntity) and return a value as Output (TRuleReturn). This output will be used in the RuleExecutor.
            </summary>
            <typeparam name="TEntity">The type of the Input</typeparam>
            <typeparam name="TRuleReturn">The type of the Output</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.DictionaryByValue`2">
            <summary>
                A dictionary with equality based on its content and not on the dictionary's reference 
                (i.e.: 2 different instances containing the same entries will be equals).
            </summary>
            <remarks>This type is not thread-safe (for hashcode updates).</remarks>
            <typeparam name="K">The type of keys in the dictionary.</typeparam>
            <typeparam name="V">The type of values in the dictionary.</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.EquallityComparer.EquatableByValue`1">
            <summary>
            Support a by-Value Equality and Unicity.
            </summary>
            <remarks>This latest implementation has been inspired from Scott Millett's book (Patterns, Principles, and Practices of Domain-Driven Design).</remarks>
            <typeparam name="T">Type of the elements.</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.Collections.EquallityComparer.EquatableByValue`1.GetAllAttributesToBeUsedForEquality">
            <summary>
            Use Yield to define every property used to diferentiate
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.EquallityComparer.EquatableByValueWithoutOrder`1">
            <summary>
            Support a by-Value Equality and Unicity where order of the elements that belongs 
            to the Unicity/Equality doesn't matter.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.ListByValue`1">
            <summary>
                A list with equality based on its content and not on the list's reference 
                (i.e.: 2 different instances containing the same items in the same order will be equals).
            </summary>
            <remarks>This type is not thread-safe (for hashcode updates).</remarks>
            <typeparam name="T">Type of the listed items.</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.SetByValue`1">
            <summary>
                A Set with equality based on its content and not on the Set's reference 
                (i.e.: 2 different instances containing the same items will be equals whatever their storage order).
            </summary>
            <remarks>This type is not thread-safe (for hashcode updates).</remarks>
            <typeparam name="T">Type of the listed items.</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1">
            <summary>
            A collection of weak references to objects.
            </summary>
            <typeparam name="T">The type of object to hold weak references to.</typeparam>
        </member>
        <member name="F:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1._list">
            <summary>
            The actual collection of strongly-typed weak references.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1.GetLiveItems">
            <summary>
            Gets a list of live objects from this collection, causing a purge.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1.Add(`0)">
            <summary>
            Adds a weak reference to an object to the collection. Does not cause a purge.
            </summary>
            <param name="item">The object to add a weak reference to.</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1.Remove(`0)">
            <summary>
            Removes a weak reference to an object from the collection. Does not cause a purge.
            </summary>
            <param name="item">The object to remove a weak reference to.</param>
            <returns>True if the object was found and removed; false if the object was not found.</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator">
            <summary>
            Used for generating UUID based on RFC 4122.
            </summary>
            <seealso href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122 - A Universally Unique IDentifier (UUID) URN Namespace</seealso>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateNodeBytes">
            <summary>
            Generates a random value for the node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateNodeBytes(System.Net.IPAddress)">
            <summary>
            Generates a node based on the first 6 bytes of an IP address.
            </summary>
            <param name="ip"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateNodeBytes(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Generates a node based on the bytes of the MAC address.
            </summary>
            <param name="mac"></param>
            <remarks>The machines MAC address can be retrieved from <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetPhysicalAddress"/>.</remarks>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateClockSequenceBytes">
            <summary>
            Generates a random clock sequence.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateClockSequenceBytes(System.DateTime)">
            <summary>
            In order to maintain a constant value we need to get a two byte hash from the DateTime.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateClockSequenceBytes(System.DateTimeOffset)">
            <summary>
            In order to maintain a constant value we need to get a two byte hash from the DateTime.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.ValueObjects.Enumeration">
            <summary>
            Defines an Enumeration with extra power (it's a class).
            You can inherit and create new types. Can add properties, etc.
            So you won't have to use switches.
            <remarks><c>from: https://lostechies.com/jimmybogard/2008/08/12/enumeration-classes </c></remarks>
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.ValueObjects.ValueObject`1">
            <summary>
                Base class for any Value Type (i.e. the 'Value Object' oxymoron of DDD).
                All you have to do is to implement the abstract methods: <see cref="M:Akrual.DDD.Utils.Domain.Utils.Collections.EquallityComparer.EquatableByValue`1.GetAllAttributesToBeUsedForEquality"/>
                <remarks><c>All of the object properties must have the setter as Private!</c></remarks>
                <remarks><c>There should be no empty constructor!</c></remarks>
            </summary>
            <typeparam name="T">Domain type to be 'turned' into a Value Type.</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.ValueObjects.ValueObject`1.#ctor">
            <summary>
            The Entity Framework needs an empty constructor. But no Value object should have one.
            </summary>
        </member>
    </members>
</doc>
