<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akrual.DDD.Utils.Domain</name>
    </assembly>
    <members>
        <member name="P:Akrual.DDD.Utils.Domain.Aggregates.IAggregateRoot.EventsLoaded">
            <summary>
            The number of events loaded into this aggregate.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.IAggregateRoot.GetEventStream">
            <summary>
            Gets all domain events that have been applied to the aggregate root instance.
            </summary>
            <returns>A collection of domain events.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.IAggregateRoot.GetChangesEventStream">
            <summary>
            Gets all new domain events that have been applied to the aggregate root instance since the fetching from the database.
            </summary>
            <returns>A collection of domain events.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.IAggregateRoot.ApplyEvents(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent})">
            <summary>
            Enuerates the supplied events and applies them in order to the aggregate.
            </summary>
            <param name="domainEvents"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.IAggregateRoot.ApplyEvents(Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent[])">
            <summary>
            Enuerates the supplied events and applies them in order to the aggregate.
            </summary>
            <param name="domainEvents"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.IAggregateRoot.ApplyOneEvent``1(``0,Akrual.DDD.Utils.Domain.Aggregates.Internal)">
            <summary>
            Applies a single event to the aggregate.
            <remarks>Normally thuis method should not be used. Because, the Aggregate
            when implementing one IApplyDomainEvent, will be automatically callede when an event is published.</remarks>
            </summary>
            <typeparam name="TEvent"></typeparam>
            <param name="ev"></param>
            <param name="nothing">This parameter is only here to block any acces to this method from outside of the library</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.IAggregateRoot.AllEventsStored">
            <summary>
            Notify the Aggregate that all events where Stored. And transfer all Events from Changes to EventStream.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1">
            <summary>
                Base class for implementing aggregate root domain objects.
                <remarks><c>No external code should access the internal objects of this Aggregate!</c></remarks>
                <remarks><c>So add properties as private or maximum internal only!</c></remarks>
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.EventsLoaded">
            <summary>
            The number of events loaded into this aggregate.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.EventsLoadedFromDB">
            <summary>
            The number of events loaded into this aggregate by the time we finished fetchihng it from the DB.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="!:AggregateRoot"/> class.
            Every constructor have to satisfy:
                <remarks><c>GUID. This must be unique in the whole Application.!</c></remarks>
                <remarks><c>You should probably extend this constructor to include every property that makes this entity unique.</c></remarks>
            </summary>
            <param name="id">Aggregate root instance id.</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.AllEventsStored">
            <summary>
            Notify the Aggregate that all events where Stored. And transfer all Events from Changes to EventStream.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.GetChangesEventStream">
            <summary>
            Gets all new domain events that have been applied to the aggregate root instance since the fetching from the database.
            </summary>
            <returns>A collection of domain events.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.GetEventStream">
            <summary>
            Gets all domain events that have been applied to the aggregate root instance.
            </summary>
            <returns>A collection of domain events.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.ApplyEvents(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent})">
            <summary>
            Enuerates the supplied events and applies them in order to the aggregate.
            </summary>
            <param name="domainEvents"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.ApplyEvents(Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent[])">
            <summary>
            Enuerates the supplied events and applies them in order to the aggregate.
            </summary>
            <param name="domainEvents"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Aggregates.AggregateRoot`1.ApplyOneEvent``1(``0,Akrual.DDD.Utils.Domain.Aggregates.Internal)">
            <summary>
            Applies a single event to the aggregate.
            <remarks>Normally thuis method should not be used. Because, the Aggregate
            when implementing one IApplyDomainEvent, will be automatically callede when an event is published.</remarks>
            </summary>
            <typeparam name="TEvent"></typeparam>
            <param name="ev"></param>
            <param name="nothing">This parameter is only here to block any acces to this method from outside of the library</param>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Entities.BaseDomainStatus">
            <summary>
            An Abstract Class to inherit when creating Entity Status
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Entities.Entity`1">
            <summary>
                Base class for any Entity Type (i.e. the 'Entity Object' of DDD).
                <remarks><c>All properties of this child classes should have the setter as private!</c></remarks>
            </summary>
            <typeparam name="T">Domain type to be 'turned' into a Entity Type.</typeparam>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Entities.Entity`1.IsValid">
            <exception cref="T:Akrual.DDD.Utils.Internal.Exceptions.ShouldNeverCallIsValidOnTheEntityException">Should never call It!!</exception>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Entities.Entity`1.#ctor(System.Guid,Akrual.DDD.Utils.Domain.Entities.IEntity)">
            <summary>
                Initializes a new instance of the <see cref="!:Entity"/> class.
                Every constructor have to satisfy:
                <remarks><c>If the entity is not an Aggregate Root, then it cannot be created without passing the owner of this entity (Some entity inside the Aggregate, maybe the Aggregate root)!</c></remarks>
                <remarks><c>GUID. This must be unique inside the Aggegate.!</c></remarks>
                <remarks><c>You should probably extend this constructor to include every property that makes this entity unique.</c></remarks>
            </summary>
            <param name="id"></param>
            <param name="owner"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Entities.Entity`1.#ctor">
            <summary>
            It should never be possible to Create an Entity without and ID and an Owner.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Exceptions.DomainException">
            <summary>
            Base Exception for exceptions related with Domain
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Factories.DefaultFactory`1">
            <summary>
            This class implements the IDefaultFactory Interface and the Factory Abstract class.
            The behaviour: The Create method will call new() and then will set the Id Property to the given guid.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.DefaultFactory`1.CreateAsOf(System.Guid,System.Nullable{System.DateTime})">
            <summary>
                Creates The aggregate, then query the event store for all it's events until a certain point. 
                And applies them in order. Then it check all later events that should be applied before the given
                point and applies them too.
                <remarks> 
                    In other words, it will give the result of a particular time point within the stream (everything we know 
                    that happened until that point in time, counting with events that may have happened later, but affects some point back in time) 
                </remarks>
            </summary>
            <returns>Returns the Filled Aggregate with all the invariants Checked.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.DefaultFactory`1.CreateAsAt(System.Guid,System.Nullable{System.DateTime})">
            <summary>
                Creates The aggregate, then query the event store for all it's events until a certain point. 
                And applies them in order.
                <remarks> 
                    In other words, it will give the result at a particular time point within the stream (what did we know as at this point in time) 
                </remarks>
            </summary>
            <returns>Returns the Filled Aggregate with all the invariants Checked.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.Factory`2.CreateDefaultInstanceAsOf(System.Guid,System.Nullable{System.DateTime})">
            <summary>
                Creates the default Aggregate. It should be already filled with the UUID.
                <remarks><c>Use GuidGenerator to generate UUID!</c></remarks>
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.Factory`2.CreateDefaultInstanceAsAt(System.Guid,System.Nullable{System.DateTime})">
            <summary>
                Creates the default Aggregate. It should be already filled with the UUID.
                <remarks><c>Use GuidGenerator to generate UUID!</c></remarks>
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.Factory`2.CreateAsOf(System.Guid,System.Nullable{System.DateTime})">
            <summary>
                Creates The aggregate, then query the event store for all it's events until a certain point. 
                And applies them in order. Then it check all later events that should be applied before the given
                point and applies them too.
                <remarks> 
                    In other words, it will give the result of a particular time point within the stream (everything we know 
                    that happened until that point in time, counting with events that may have happened later, but affects some point back in time) 
                </remarks>
            </summary>
            <returns>Returns the Filled Aggregate with all the invariants Checked.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.Factory`2.CreateAsAt(System.Guid,System.Nullable{System.DateTime})">
            <summary>
                Creates The aggregate, then query the event store for all it's events until a certain point. 
                And applies them in order.
                <remarks> 
                    In other words, it will give the result at a particular time point within the stream (what did we know as at this point in time) 
                </remarks>
            </summary>
            <returns>Returns the Filled Aggregate with all the invariants Checked.</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Factories.FactoryCreationExecutingContext`2">
            <summary>
            Used to Pass information to the Factory. So we can alter the behaviour of the factory.
            </summary>
            <typeparam name="TAggregate"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Factories.FactoryCreationExecutingContext`2.ObjectBeingCreated">
            <summary>
            Is the object being created. So if there is a need to change how 
            it is created or some internal property use it
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Factories.IDefaultFactory`1">
            <summary>
            This interface represents a default implementation of an Factory
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.IDefaultFactory`1.CreateAsOf(System.Guid,System.Nullable{System.DateTime})">
            <summary>
                Creates The aggregate, then query the event store for all it's events until a certain point. 
                And applies them in order. Then it check all later events that should be applied before the given
                point and applies them too.
                <remarks> 
                    In other words, it will give the result of a particular time point within the stream (everything we know 
                    that happened until that point in time, counting with events that may have happened later, but affects some point back in time) 
                </remarks>
            </summary>
            <returns>Returns the Filled Aggregate with all the invariants Checked.</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.IDefaultFactory`1.CreateAsAt(System.Guid,System.Nullable{System.DateTime})">
            <summary>
                Creates The aggregate, then query the event store for all it's events until a certain point. 
                And applies them in order.
                <remarks> 
                    In other words, it will give the result at a particular time point within the stream (what did we know as at this point in time) 
                </remarks>
            </summary>
            <returns>Returns the Filled Aggregate with all the invariants Checked.</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Factories.InstanceFactory.IInstantiator`1">
            <summary>
            This is a dangerous Interface. Because it creates one Async Scope just to create a new instance.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Factories.InstanceFactory.Instantiator`1">
            <summary>
            This is a dangerous Class. Because it creates one Async Scope just to create a new instance.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Factories.InstanceFactory.Instantiator`1.Create(System.Guid)">
            <summary>
            <remarks>Dangerous!</remarks> Because it creates one new async scope to create a new instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.Dispatcher.IDomainCommandDispatcher">
            <summary>
            Represents the interface of a command dispatcher. All Commands will be dispatched through a dispatcher
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand">
            <summary>
            Base class for implementing domain Commands that represent the will for something to happen.
            It by default expect the handler to return an IEnumerable&lt;DomainEvent&gt;
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand.AggregateRootId">
            <summary>
            Gets the Aggregate Root id.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand.#ctor(System.Guid,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand"/> class.
            </summary>
            <param name="aggregateRootId">Aggregate Root id.</param>
            <param name="entityVersion">Entity instance version.</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.DomainCommand"/> class.
            </summary>
            <param name="aggregateRootId">Aggregate Root instance id.</param>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext">
            <summary>
            Represents a command context for aggregate command handler handling command.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext.Add``2(``0)">
            <summary>Add a new aggregate into the current command context.
            </summary>
            <param name="aggregateRoot"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext.Get``2(System.Object,System.Boolean)">
            <summary>Get an aggregate from the current command context.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TInside"></typeparam>
            <param name="id"></param>
            <param name="firstFromCache"></param>
            <returns></returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext.SetResult(System.String)">
            <summary>Set the command handle result.
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.ICommandContext.GetResult">
            <summary>Get the command handle result.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.IDomainCommand">
            <summary>
            Domain Command that represents the will for something to happen
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainCommands.IHandleDomainCommand`1">
            <summary>Represents generic command handler.
            </summary>
            <typeparam name="TCommand"></typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent">
            <summary>
            Base class for implementing domain events that represent changes in a domain entity.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent.AggregateRootId">
            <summary>
            Gets the entity id.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent.EventName">
            <summary>
            Defines the Event Name that will be used in the Store.
            It is important to keep this name the same. Because, otherwise, 
            there will be some problems when fetching the streams.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent.#ctor(System.Guid,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.DomainEvent"/> class.
            </summary>
            <param name="eventGuid">Event id.</param>
            <param name="aggregateRootId">Entity instance id.</param>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IDomainEvent">
            <summary>
            Domain event that represents changes in a domain entity.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.IHandleDomainEvent`1">
            <summary>
            Implemented by an aggregate once for each event type it can apply.
            </summary>
            <typeparam name="TEvent"></typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.IRecordedEvent">
            <summary>
            Represents an Event That is recorded into the event Store. It has a new property that
            indicates the exact time the event was inserted into the stream.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.IRecordedEvent.Event">
            <summary>
            The recorded Event.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.IRecordedEvent.CreatedAt">
            <summary>
            The date and time in which the event was stored.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.IUndoEvent">
            <summary>
            Represents an Event That Will Undo another Event that already happened.
            The EventGuid property will point to the event already happened. 
            And the Event Property will be the event data to undo the other event.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.IUndoEvent.Event">
            <summary>
            The event data to undo the other event.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.IUndoEvent.EventGuid">
            <summary>
            Points to the event already happened.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.RecordedEvent">
            <summary>
            Represents an Event That is recorded into the event Store. It has a new property that
            indicates the exact time the event was inserted into the stream.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.RecordedEvent.Event">
            <summary>
            The recorded Event.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.RecordedEvent.CreatedAt">
            <summary>
            The date and time in which the event was stored.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.UndoEvent">
            <summary>
            Represents an Event That Will Undo another Event that already happened.
            The EventGuid property will point to the event already happened. 
            And the Event Property will be the event data to undo the other event.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.UndoEvent.Event">
            <summary>
            The event data to undo the other event.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.DomainEvents.SpecialEvents.UndoEvent.EventGuid">
            <summary>
            Points to the event already happened.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.IMessaging">
            <summary>
            Messages (and not objects, objects are data + behavior).
            In some respects much like DTOs, they communicate data 
            about an event and they themselves encapsulate no behavior
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.IHandledMessage`1">
            <summary>
            Represents Any message that will be used to represent a Command or an Event.
            </summary>
        </member>
        <member name="P:Akrual.DDD.Utils.Domain.Messaging.IHandledMessage`1.AggregateRootId">
            <summary>
            Gets the entity id.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Messaging.Saga.IProcessManagerRedirect`1">
            <summary>
            Interface that must be added to a Process Manager Class for each redirection that it will implement.
            </summary>
            <typeparam name="TInEvent">The event that the process manager will receive</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Messaging.Saga.IProcessManagerRedirect`1.Redirect(`0)">
            <summary>
            For a given Event, it return a list of messages (Events and Commands) that shall be published/dispatched
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Repositories.IAsyncDomainRepository`2">
            <summary>
            Asynchronous domain repository for a given aggregate root type.
            </summary>
            <typeparam name="TAggregate">The type of the aggregate root.</typeparam>
            <typeparam name="T">The type of the aggregate root Inner object.</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Repositories.IAsyncDomainRepository`2.FindByIdAsync(System.Guid)">
            <summary>
            Asynchronously finds an aggregate root instance from the repository using its id.
            </summary>
            <param name="id">Aggregate root instance id.</param>
            <returns>Aggregate root instance.</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.BaseDomainRule`2">
            <summary>
            Base class for Rule Definition. It should receive one Entity as input (TEntity) and return a value as Output (TRuleReturn). This output will be used in the RuleExecutor.
            </summary>
            <typeparam name="TEntity">The type of the Input</typeparam>
            <typeparam name="TRuleReturn">The type of the Output</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRule`2.EvaluateRules(`0)">
            <summary>
            Evaluate all Rules to a specific entity and and return output
            </summary>
            <param name="entity">Any entity object that will be analysed</param>
            <returns>Evaluated value</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2">
            <summary>
            Represents a rule Engine Executor. It will Crunch all the Rules associated to it and return the final output.
            </summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TRuleReturn"></typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.#ctor(Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}[])">
            <summary>
            Instantiates the Rule Evaluator passing the rules as parameters
            </summary>
            <param name="rules">The rules to instantiate the evaluator</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.#ctor(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}})">
            <summary>
            Instantiates the Rule Evaluator passing the rules as an IEnumerable as parameter
            </summary>
            <param name="rules">The rules to instantiate the evaluator</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.AddRule(Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}[])">
            <summary>
            Adds Rule to Rules Evaluation. And return True if succeeds
            </summary>
            <param name="rules">The rules beeing added to evaluation</param>
            <returns>True if added sucessfully</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.AddRule(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}})">
            <summary>
            Adds Rule to Rules Evaluation. And return True if succeeds
            </summary>
            <param name="rules">The rules beeing added to evaluation</param>
            <returns>True if added sucessfully</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.RemoveRule(Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}[])">
            <summary>
                Removes Rule to Rules Evaluation. And return True if succeeds
                <remarks><c>It will only work if the instance being passed to be removed is the same as the one initially added!</c></remarks>
            </summary>
            <param name="rules">The rules beeing removed to evaluation</param>
            <returns>True if removed sucessfully</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.RemoveRule(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,`1}})">
            <summary>
                Removes Rule to Rules Evaluation. And return True if succeeds
                <remarks><c>It will only work if the instance being passed to be removed is the same as the one initially added!</c></remarks>
            </summary>
            <param name="rules">The rules beeing removed to evaluation</param>
            <returns>True if removed sucessfully</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.BaseDomainRuleEvaluator`2.ExecuteAllRules(`0)">
            <summary>
                Evaluates all Rules registered to the given entity and return the result.
                <remarks><c>Here is added the logic of the order, min, max, etc.</c></remarks>
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.AndDomainRule`1">
            <summary>
            This Rule is used to wrap two Boolean rules using an AND expression.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.AndDomainRule`1.#ctor(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0},Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            Creates a Rule that is used to wrap two Boolean rules using an AND expression.
            </summary>
            <param name="left">Left side of the Boolean Expression</param>
            <param name="right">Right side of the Boolean Expression</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.AndDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BooleanDomainRuleBuilder`1">
            <summary>
            A builder to create Complex DomainRules based on Boolean Expressions. It can Wrap rules in AND, OR, XOR statements.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BooleanDomainRuleBuilder`1.#ctor(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            creates a builder to create Complex DomainRules based on Boolean Expressions. It can Wrap rules in AND, OR, XOR statements.
            It receives an initial rule. If none is provided, it will start with a Always true rule.
            </summary>
            <param name="initial"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BooleanDomainRuleBuilder`1.Create">
            <summary>
            Start the Fluent Creation Proccess
            </summary>
            <returns>Fluent object to create</returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BooleanDomainRuleBuilder`1.And(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            
            </summary>
            <param name="initial"></param>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule`1">
            <summary>
            This is a Base Class to define any rules that return a Boolean.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.FalseDomainRule`1">
            <summary>
            This is a Dummy Rule used to start some Complex boolean rule.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.FalseDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.OrDomainRule`1">
            <summary>
            This Rule is used to wrap two Boolean rules using an OR expression.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.OrDomainRule`1.#ctor(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0},Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            Creates a Rule that is used to wrap two Boolean rules using an OR expression.
            </summary>
            <param name="left">Left side of the Boolean Expression</param>
            <param name="right">Right side of the Boolean Expression</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.OrDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.TrueDomainRule`1">
            <summary>
            This is a Dummy Rule used to start some Complex boolean rule.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.TrueDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.XorDomainRule`1">
            <summary>
            This Rule is used to wrap two Boolean rules using an XOR expression.
            </summary>
            <typeparam name="TEntity">Any Entity object</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.XorDomainRule`1.#ctor(Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0},Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.BoolenaDomainRule{`0})">
            <summary>
            Creates a Rule that is used to wrap two Boolean rules using an XOR expression.
            </summary>
            <param name="left">Left side of the Boolean Expression</param>
            <param name="right">Right side of the Boolean Expression</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonDomainRules.Boolean.XorDomainRule`1.EvaluateRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.CommonRuleExecutors.BooleanDomainRuleEvaluator`1">
            <inheritdoc />
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonRuleExecutors.BooleanDomainRuleEvaluator`1.#ctor(Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,System.Boolean}[])">
            <inheritdoc />
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonRuleExecutors.BooleanDomainRuleEvaluator`1.#ctor(System.Collections.Generic.IEnumerable{Akrual.DDD.Utils.Domain.Rules.IDomainRule{`0,System.Boolean}})">
            <inheritdoc />
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Rules.CommonRuleExecutors.BooleanDomainRuleEvaluator`1.ExecuteAllRules(`0)">
            <inheritdoc />
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Rules.IDomainRule`2">
            <summary>
            Base interface for Rule Definition. It should receive one Entity as input (TEntity) and return a value as Output (TRuleReturn). This output will be used in the RuleExecutor.
            </summary>
            <typeparam name="TEntity">The type of the Input</typeparam>
            <typeparam name="TRuleReturn">The type of the Output</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.DictionaryByValue`2">
            <summary>
                A dictionary with equality based on its content and not on the dictionary's reference 
                (i.e.: 2 different instances containing the same entries will be equals).
            </summary>
            <remarks>This type is not thread-safe (for hashcode updates).</remarks>
            <typeparam name="K">The type of keys in the dictionary.</typeparam>
            <typeparam name="V">The type of values in the dictionary.</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.EquallityComparer.EquatableByValue`1">
            <summary>
            Support a by-Value Equality and Unicity.
            </summary>
            <remarks>This latest implementation has been inspired from Scott Millett's book (Patterns, Principles, and Practices of Domain-Driven Design).</remarks>
            <typeparam name="T">Type of the elements.</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.Collections.EquallityComparer.EquatableByValue`1.GetAllAttributesToBeUsedForEquality">
            <summary>
            Use Yield to define every property used to diferentiate
            </summary>
            <returns></returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.EquallityComparer.EquatableByValueWithoutOrder`1">
            <summary>
            Support a by-Value Equality and Unicity where order of the elements that belongs 
            to the Unicity/Equality doesn't matter.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.ListByValue`1">
            <summary>
                A list with equality based on its content and not on the list's reference 
                (i.e.: 2 different instances containing the same items in the same order will be equals).
            </summary>
            <remarks>This type is not thread-safe (for hashcode updates).</remarks>
            <typeparam name="T">Type of the listed items.</typeparam>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.Collections.SetByValue`1">
            <summary>
                A Set with equality based on its content and not on the Set's reference 
                (i.e.: 2 different instances containing the same items will be equals whatever their storage order).
            </summary>
            <remarks>This type is not thread-safe (for hashcode updates).</remarks>
            <typeparam name="T">Type of the listed items.</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1" -->
        <member name="F:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1._list">
            <summary>
            The actual collection of strongly-typed weak references.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1.GetLiveItems">
            <summary>
            Gets a list of live objects from this collection, causing a purge.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1.Add(`0)">
            <summary>
            Adds a weak reference to an object to the collection. Does not cause a purge.
            </summary>
            <param name="item">The object to add a weak reference to.</param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.Collections.WeakCollection`1.Remove(`0)">
            <summary>
            Removes a weak reference to an object from the collection. Does not cause a purge.
            </summary>
            <param name="item">The object to remove a weak reference to.</param>
            <returns>True if the object was found and removed; false if the object was not found.</returns>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator">
            <summary>
            Used for generating UUID based on RFC 4122.
            </summary>
            <seealso href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122 - A Universally Unique IDentifier (UUID) URN Namespace</seealso>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateNodeBytes">
            <summary>
            Generates a random value for the node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateNodeBytes(System.Net.IPAddress)">
            <summary>
            Generates a node based on the first 6 bytes of an IP address.
            </summary>
            <param name="ip"></param>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateNodeBytes(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Generates a node based on the bytes of the MAC address.
            </summary>
            <param name="mac"></param>
            <remarks>The machines MAC address can be retrieved from <see cref="M:System.Net.NetworkInformation.NetworkInterface.GetPhysicalAddress"/>.</remarks>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateClockSequenceBytes">
            <summary>
            Generates a random clock sequence.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateClockSequenceBytes(System.DateTime)">
            <summary>
            In order to maintain a constant value we need to get a two byte hash from the DateTime.
            </summary>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.Utils.UUID.GuidGenerator.GenerateClockSequenceBytes(System.DateTimeOffset)">
            <summary>
            In order to maintain a constant value we need to get a two byte hash from the DateTime.
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.ValueObjects.Enumeration">
            <summary>
            Defines an Enumeration with extra power (it's a class).
            You can inherit and create new types. Can add properties, etc.
            So you won't have to use switches.
            <remarks><c>from: https://lostechies.com/jimmybogard/2008/08/12/enumeration-classes </c></remarks>
            </summary>
        </member>
        <member name="T:Akrual.DDD.Utils.Domain.ValueObjects.ValueObject`1">
            <summary>
                Base class for any Value Type (i.e. the 'Value Object' oxymoron of DDD).
                All you have to do is to implement the abstract methods: <see cref="M:Akrual.DDD.Utils.Domain.Utils.Collections.EquallityComparer.EquatableByValue`1.GetAllAttributesToBeUsedForEquality"/>
                <remarks><c>All of the object properties must have the setter as Private!</c></remarks>
                <remarks><c>There should be no empty constructor!</c></remarks>
            </summary>
            <typeparam name="T">Domain type to be 'turned' into a Value Type.</typeparam>
        </member>
        <member name="M:Akrual.DDD.Utils.Domain.ValueObjects.ValueObject`1.#ctor">
            <summary>
            The Entity Framework needs an empty constructor. But no Value object should have one.
            </summary>
        </member>
    </members>
</doc>
